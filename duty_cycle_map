#!/usr/bin/env python
import matplotlib.pyplot as plt
import datetime
import psycopg2
import psycopg2.extras
import re
import os
import seaborn
from loguru import logger as log

"""
Draws a graph showing the distribution of timestamps relative to
the duty cycle.

Taking the battery table as the duty cycle clock, convert the
timestamps in the accel and gps tables into DC-relative time
offsets and draw a graph of those values.

For each user, draw two graphs:
    GRAPH 1: histograms of seconds offset between DC signals 
    GRAPH 2: histogram of seconds offset btwn record_time and most recent DC signal
"""

try:
    db_host = os.environ["SQL_LOCAL_SERVER"]
    db_host_port = int(os.environ["SQL_LOCAL_PORT"])
    db_user = os.environ["SQL_USER"]
    db_name = os.environ["SQL_DB"]
    db_schema = os.environ["SQL_SCHEMA"]
except KeyError as err:
    log.error("A required runtime environment variable was not found.")
    log.error(err)
    log.error("Have you set up the run-time secrets?")
    exit(1)

# SQL commands for getting data out of the tables of interest
user_dc_signals_sql = """SELECT user_id, record_time
                         FROM level_0.tmpelemetrysskwbatterycsv
                         ORDER BY user_id, record_time;
                         """

sample_offsets_sql = """
    SELECT record_time
    FROM level_0.tmpelemetrysskwaccelcsv
    WHERE user_id = %s
    ORDER BY user_id, record_time;
"""


def compute_spacing(timestamps):
    """
    Given a series of timestamps, return a list of ms offsets
    between successive entries in the series.
    """
    last = None
    ms_spaces = []
    for this,val in timestamps:
        if this and last:
            interval = this - last
            ms_spaces.append(interval.microseconds/1000)
        else:
            ms_spaces.append(-1)
        last = this
    return ms_spaces


log.info("Creating connection to DB...")
with psycopg2.connect(user=db_user,
                    host=db_host,
                    port=db_host_port,
                    database=db_name) as conn:

    log.info("Getting user list...")
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    cur.execute(user_dc_signals_sql) #"SELECT DISTINCT user_id FROM level_0.tmpelemetrysskwbatterycsv;")
    all_signals = cur.fetchall()
    users = set([x['user_id'] for x in all_signals])
    log.info(f"Unique users = {users}")

    numfigs = len(users)
    # f = plt.figure(figsize=(12,2*numfigs))
    f = plt.figure()
    f.suptitle("Unconflicted Timestamps - GPS")

    for i,user in enumerate([6403,]): #users):
        log.info(f"Drawing signal spacing histogram...")
        user_signals = [(x['record_time'],1) for x in all_signals if x['user_id'] == user]
        log.info(f"Found {len(user_signals)} signals for user {user}")
        user_spacings = compute_spacing(user_signals)
        log.info(f"Found {len(user_spacings)} spacings for user {user}")

        log.info(f"Signals sample -> {user_signals[-5:]}")
        log.info(f"Spacings sample -> {user_spacings[-5:]}")

        # print(f"Reading SQL data for user {user}...")
        # cur.execute(telemetry_sql%user)
        # sparse_collision_counts = cur.fetchall()

        # full_collision_counts = [] 
        # last_timestamp = sparse_collision_counts[0][0]
        # # now march through each sequential pair of samples
        # # and if there are gaps between them with missing
        # # seconds, insert additional samples with 0 collisions
        # print(f"Reindexing data...")
        # for sparse_collision in sparse_collision_counts:
        #     sample_time = sparse_collision[0]
        #     if sample_time - last_timestamp > datetime.timedelta(seconds = 2):
        #         # add one new record just after previous 
        #         t = last_timestamp + datetime.timedelta(seconds=1)
        #         full_collision_counts.append( (t, 0) )
        #         # and another just before current
        #         t = sample_time - datetime.timedelta(seconds=1)
        #         full_collision_counts.append( (t, 0) )

        #     full_collision_counts.append(sparse_collision)
        #     last_timestamp = sample_time

        # print(f"Found {len(sparse_collision_counts)} samples in DB.")
        # print(f"Now {len(full_collision_counts)} samples in full set.")


        log.info(f"Generating plot...")
        # ax = f.add_subplot(numfigs,1,i+1)
        plt.plot(*zip(*user_signals))
        # ax.set_ylabel(f"User {user}")
        # df.plot(figsize=(12,3))
        # fname = f"plot-{user}.png"
        # print(f"Saving {fname}...")
    fname = "spacings.png"
    f.savefig(fname,dpi=150)
    log.info(f"Done. Image in {fname}")
