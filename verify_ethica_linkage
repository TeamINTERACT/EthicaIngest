#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""

This script analyses a coordinator's linkage table of Ethica
user data and conducts a number of simple tests to verify the 
integrity of the data, prior to ingest.


This should be run prior to ingest, to be sure the data is reasonably
complete and well-formed.

Usage:
  verify_ethica_linkage [options] LINKAGECSV TELEMETRY_DIR 
  verify_ethica_linkage -h | --help | -V | --version

Options:
    -h            Display this help info
    -t ID         Produce trace log of all decisions about user #ID
    -v,--verbose  Provide more verbose output
"""
import os
import re
import sys
import csv
from datetime import datetime
from docopt import docopt
from loguru import logger as log
from tqdm import tqdm

# PREP
# Ingest linkage tables into ethica_assignments
#    possibly extend existing linkage loader
#    otherwise write one specifically for ethica linkages

# TESTS
# X Each ethica user has exactly one record
# X Each ethica user has corresponding interact_id
# - Each ethica user has well-formed wear-dates

# - Report linkage iids missing from gps
# - Report linkage iids missing from accel
# - Does linkage have wear dates for Ethica? If so, validate them
# -     each ethica user has ingestible telemetry files in archive
# -     no ingestible telemetry files exist for unknown ethica users

iids = set([])
eids = set([])

def validate_iid(idstr):
    """
    Given an Interact ID in string form, ensure it's well formed.
    Return True if so, False otherwise.
    """
    if not len(idstr.strip()) > 8:
        log.error(f"Interact ID '{idstr}' is not long enough.")
        return False
    try:
        iid = int(idstr)
    except ValueError:
        log.error(f"Interact ID '{idstr}' is not an integer.")
        return False
    global iids
    iids.add(iid)
    return True

def validate_eid(idstr):
    """
    Given an Ethica ID in string form, ensure it's well formed and
    unique.  Return True if so, False otherwise.
    """
    try:
        eid = int(idstr)
    except ValueError: # filter B
        log.info(f"Ethica ID '{idstr}' is not an integer.")
        return False
    global eids
    if eid in eids: # filter A
        log.error(f"Redundant record for Ethica ID '{idstr}'.")
        return False
    eids.add(eid)
    return True

def validate_wear_dates(row):
    """
    Given an Ethica record, ensure it has well-formed start and
    end dates. Return True if so, False otherwise.
                            DO NOT USE!
    Wear dates are only valid for SenseDoc data. With SD, data
    capture begins the moment the device is booted, so it captures
    activity of the coordinator prior to delivery to the participant,
    and then again after the device has been recovered. Wear dates
    are used in that situation to filter out the coordinator data.
    But Ethica data is different and has no coordinator "pollution"
    that needs to be removed.

    I'm leaving this code here though, with this comment, so that
    nobody is tempted to add date filters back in at a later time.
    """
    return True
    try:
        start_str = row['start_date']
        end_str = row['end_date']
        start_date = datetime.strptime(start_str,"%Y-%m-%d") 
        end_date = datetime.strptime(end_str,"%Y-%m-%d") 
    except KeyError:
        log.error(f"EID '{row['Ethica ID']}' has missing date field(s)")
        return False
    except ValueError:
        log.error(f"EID '{row['Ethica ID']}' has missing/invalid date info {start_str} - {end_str}")
        return False
    if start_date >= end_date:
        log.error(f"EID '{row['Ethica ID']}' has invalid date window {start_str} - {end_str}")
        return False
    log.critical(f"EID '{row['Ethica ID']}' has good date window {start_str} - {end_str}")
    return True


if __name__ == '__main__':
    args = docopt(__doc__, version='0.1.1')

    linkage_filename = args['LINKAGECSV']
    telemetry_dir = args['TELEMETRY_DIR']

    # replace default logger with something cleaner
    log.remove()
    loglevel = "INFO"
    if args['--verbose']:
        loglevel = "DEBUG"
    log.add(sys.stderr, 
            colorize=True,
            format="<lvl>{level}</lvl>|{message}",
            level="WARNING")
    log.add("Logs/verify_linkage_{time}.log", 
            format="<lvl>{level}</lvl>|{message}",
            level=loglevel)

    with open(linkage_filename,'r',encoding='ISO-8859-1') as fcsv:
        reader = csv.DictReader(fcsv,delimiter=',')
        for rownum,row in enumerate(list(reader)):
            log.info(f"Reading CSV row {rownum}")
            eid = row['Ethica ID']
            if not eid: 
                log.info(f"CSV row #{rownum} has no eid")
                continue # not an ethica row
            if not validate_eid(eid):
                continue # we're only interested in ethica users
            iid = row['interact_id']
            if not iid or not validate_iid(iid): # filter C 
                log.error(f"Ethica user {eid} has no iid")
    print(f"There were {len(eids)} apparent Ethica users in file.")
    exit(0)

    log.info("Expecting %d directories."%len(expected_dirs))
    # print('\n'.join(expected_dirs))

    count_found_dirs = 0
    count_unfound_dirs = 0
    for d in expected_dirs:
        path = os.path.join(root_dir, d)
        if os.path.isdir(path):
            count_found_dirs += 1
            # Now look in that expected dir and validate SDB fname
            fnpat = "SD\d+fw\d+_\d+_\d+[^.]*\.[sS][dD][bB]"
            for fn in os.listdir(path):
                if fn.lower().endswith('.sdb'):
                    prob = []
                    m = re.search(fnpat,fn)
                    if not m:
                        log("  BAD SDB FNAME: %s"%os.path.join(path,fn))
        else:
            log("  EXPECTED DIRECTORY MISSING: '%s'" % path)
            count_unfound_dirs += 1

    # now look for unexpected directories
    count_unexpected_dirs = 0
    for child in os.listdir(root_dir):
        if not child in expected_dirs and not child in ignoring_dirs:
            for childf in os.listdir(os.path.join(root_dir,child)):
                if childf.endswith('.sdb'):
                    log("  DIRECTORY IS UNEXPECTED: '%s'" % child)
                    count_unexpected_dirs += 1
                    break

    log("Found %d of the %d expected directories." % (count_found_dirs,len(expected_dirs)), screen=True)
    log("%d are missing." % count_unfound_dirs, screen=True)
    log("Found %d unexpected directories." % count_unexpected_dirs, screen=True)
    log("Found %d data folders without wear-date records."%len(iids_with_missing_dates), screen=True)
