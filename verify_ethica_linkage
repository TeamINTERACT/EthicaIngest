#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""

This script analyses a coordinator's linkage table of Ethica
user data and conducts a number of simple tests to verify the 
integrity of the data, prior to ingest.


This should be run prior to ingest, to be sure the data is reasonably
complete and well-formed.

Usage:
  verify_ethica_linkage [options] LINKAGECSV TELEMETRY_DIR 
  verify_ethica_linkage -h | --help | -V | --version

Options:
    -h            Display this help info
    -t ID         Produce trace log of all decisions about user #ID
    -v,--verbose  Provide more verbose output
"""
import os
import re
import sys
import csv
import datetime
from docopt import docopt
from loguru import logger as log
from tqdm import tqdm

# PREP
# Ingest linkage tables into ethica_assignments
#    possibly extend existing linkage loader
#    otherwise write one specifically for ethica linkages

# TESTS
# - Each ethica user has exactly one record
# - Each ethica user has corresponding interact_id
# - Each ethica user has well-formed wear-dates

# - Report linkage iids missing from gps
# - Report linkage iids missing from accel
# - Does linkage have wear dates for Ethica? If so, validate them
# -     each ethica user has ingestible telemetry files in archive
# -     no ingestible telemetry files exist for unknown ethica users

iids = set([])
eids = set([])

def validate_iid(idstr):
    """
    Given an Interact ID in string form, ensure it's well formed.
    Return True if so, False otherwise.
    """
    if not len(idstr.strip()) > 8:
        log.error(f"Interact ID '{idstr}' is not long enough.")
        return False
    try:
        iid = int(idstr)
    except ValueError:
        log.error(f"Interact ID '{idstr}' is not an integer.")
        return False
    global iids
    iids.add(iid)
    return True

def validate_eid(idstr):
    """
    Given an Ethica ID in string form, ensure it's well formed and
    unique.  Return True if so, False otherwise.
    """
    try:
        eid = int(idstr)
    except ValueError:
        log.info(f"Ethica ID '{idstr}' is not an integer.")
        return False
    global eids
    if eid in eids:
        log.error(f"Redundant record for Ethica ID '{idstr}'.")
        return False
    eids.add(eid)
    return True



if __name__ == '__main__':
    args = docopt(__doc__, version='0.1.1')

    linkage_filename = args['LINKAGECSV']
    telemetry_dir = args['TELEMETRY_DIR']

    # replace default logger with something cleaner
    log.remove()
    loglevel = "INFO"
    if args['--verbose']:
        loglevel = "DEBUG"
    log.add(sys.stderr, 
            colorize=True,
            format="<lvl>{level}</lvl>|{message}",
            level="WARNING")
    log.add("Logs/verify_linkage_{time}.log", 
            format="<lvl>{level}</lvl>|{message}",
            level=loglevel)

    with open(linkage_filename,'r',encoding='ISO-8859-1') as fcsv:
        reader = csv.DictReader(fcsv,delimiter=',')
        for rownum,row in enumerate(list(reader)):
            log.info(f"Reading CSV row {rownum}")
            iid = row['interact_id']
            if not iid: 
                log.error(f"CSV row #{rownum} has no iid")
                continue
            validate_iid(iid)
            eid = row['Ethica ID']
            if not eid: 
                log.info(f"CSV row #{rownum} has no eid")
                continue # not an ethica row
            validate_eid(eid)
    exit(0)

    log.info("Expecting %d directories."%len(expected_dirs))
    # print('\n'.join(expected_dirs))

    count_found_dirs = 0
    count_unfound_dirs = 0
    for d in expected_dirs:
        path = os.path.join(root_dir, d)
        if os.path.isdir(path):
            count_found_dirs += 1
            # Now look in that expected dir and validate SDB fname
            fnpat = "SD\d+fw\d+_\d+_\d+[^.]*\.[sS][dD][bB]"
            for fn in os.listdir(path):
                if fn.lower().endswith('.sdb'):
                    prob = []
                    m = re.search(fnpat,fn)
                    if not m:
                        log("  BAD SDB FNAME: %s"%os.path.join(path,fn))
        else:
            log("  EXPECTED DIRECTORY MISSING: '%s'" % path)
            count_unfound_dirs += 1

    # now look for unexpected directories
    count_unexpected_dirs = 0
    for child in os.listdir(root_dir):
        if not child in expected_dirs and not child in ignoring_dirs:
            for childf in os.listdir(os.path.join(root_dir,child)):
                if childf.endswith('.sdb'):
                    log("  DIRECTORY IS UNEXPECTED: '%s'" % child)
                    count_unexpected_dirs += 1
                    break

    log("Found %d of the %d expected directories." % (count_found_dirs,len(expected_dirs)), screen=True)
    log("%d are missing." % count_unfound_dirs, screen=True)
    log("Found %d unexpected directories." % count_unexpected_dirs, screen=True)
    log("Found %d data folders without wear-date records."%len(iids_with_missing_dates), screen=True)
